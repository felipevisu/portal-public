type ApproveDocumentFile {
  documentFile: DocumentFile
  errors: [Error!]!
}

type Attribute implements Node {
  choices(after: String, before: String, filter: AttributeValueFilterInput, first: Int, last: Int, sortBy: AttributeChoicesSortingInput): AttributeValueCountableConnection
  documents(after: String, before: String, first: Int, last: Int): DocumentCountableConnection!
  entityType: AttributeEntityTypeEnum
  entries(after: String, before: String, first: Int, last: Int): EntryCountableConnection!
  filterableInDashboard: Boolean!
  filterableInWebsite: Boolean!
  id: ID!
  inputType: AttributeInputTypeEnum
  name: String
  slug: String
  type: AttributeTypeEnum
  valueRequired: Boolean!
  visibleInWebsite: Boolean!
  withChoices: Boolean!
}

enum AttributeChoicesSortField {
  """Sort attribute choice by name."""
  NAME

  """Sort attribute choice by slug."""
  SLUG
}

input AttributeChoicesSortingInput {
  direction: OrderDirection!

  """Sort attribute choices by the selected field."""
  field: AttributeChoicesSortField!
}

type AttributeCountableConnection {
  edges: [AttributeCountableEdge!]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """A total count of items in the collection."""
  totalCount: Int
}

type AttributeCountableEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Attribute!
}

type AttributeCreate {
  attribute: Attribute
  errors: [Error!]!
}

input AttributeCreateInput {
  entityType: AttributeEntityTypeEnum
  filterableInDashboard: Boolean
  filterableInWebsite: Boolean
  inputType: AttributeInputTypeEnum
  name: String!
  slug: String
  type: AttributeTypeEnum!
  valueRequired: Boolean
  values: [AttributeValueCreateInput!]
  visibleInWebsite: Boolean
}

type AttributeDelete {
  attribute: Attribute
  errors: [Error!]!
}

"""An enumeration."""
enum AttributeEntityTypeEnum {
  PROVIDER
  VEHICLE
}

input AttributeFilterInput {
  filterableInDashboard: Boolean
  filterableInWebsite: Boolean
  ids: [ID!]
  search: String
  slugs: [String!]
  type: AttributeTypeEnum
  valueRequired: Boolean
  visibleInWebsite: Boolean
}

input AttributeInput {
  boolean: Boolean
  date: DateRangeInput
  dateTime: DateTimeRangeInput
  slug: String!
  values: [String!]
  valuesRange: IntRangeInput
}

"""An enumeration."""
enum AttributeInputTypeEnum {
  BOOLEAN
  DATE
  DROPDOWN
  FILE
  MULTISELECT
  PLAIN_TEXT
  REFERENCE
  SWATCH
}

enum AttributeSortField {
  """Sort attributes by the filterable in dashboard flag"""
  FILTERABLE_IN_DASHBOARD

  """Sort attributes by the filterable in storefront flag"""
  FILTERABLE_IN_WEBSITE

  """Sort attributes by name"""
  NAME

  """Sort attributes by slug"""
  SLUG

  """Sort attributes by the value required flag"""
  VALUE_REQUIRED

  """Sort attributes by visibility in the storefront"""
  VISIBLE_IN_WEBSITE
}

input AttributeSortingInput {
  direction: OrderDirection!

  """Sort attributes by the selected field."""
  field: AttributeSortField!
}

"""An enumeration."""
enum AttributeTypeEnum {
  DOCUMENT
  PROVIDER
  VEHICLE
  VEHICLE_AND_PROVIDER
}

type AttributeUpdate {
  attribute: Attribute
  errors: [Error!]!
}

input AttributeUpdateInput {
  addValues: [AttributeValueUpdateInput!]
  filterableInDashboard: Boolean
  filterableInWebsite: Boolean
  name: String
  removeValues: [ID!]
  slug: String
  valueRequired: Boolean
  visibleInWebsite: Boolean
}

type AttributeValue implements Node {
  boolean: Boolean
  date: Date
  file: File
  id: ID!
  inputType: AttributeInputTypeEnum
  name: String
  plainText: String
  reference: ID
  slug: String
  value: String
}

type AttributeValueCountableConnection {
  edges: [AttributeValueCountableEdge!]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """A total count of items in the collection."""
  totalCount: Int
}

type AttributeValueCountableEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: AttributeValue!
}

type AttributeValueCreate {
  attribute: Attribute
  attributeValue: AttributeValue
  errors: [Error!]!
}

input AttributeValueCreateInput {
  fileUrl: String
  name: String!
  plainText: String
  value: String
}

type AttributeValueDelete {
  attribute: Attribute
  attributeValue: AttributeValue
  errors: [Error!]!
}

input AttributeValueFilterInput {
  ids: [ID!]
  search: String
}

input AttributeValueInput {
  boolean: Boolean
  contentType: String
  date: Date
  dropdown: AttributeValueSelectableTypeInput
  file: String
  id: ID
  multiselect: [AttributeValueSelectableTypeInput!]
  numeric: String
  plainText: String

  """List of entity IDs that will be used as references."""
  references: [ID!]
  values: [String!]
}

input AttributeValueSelectableTypeInput {
  id: ID
  value: String
}

type AttributeValueUpdate {
  attribute: Attribute
  attributeValue: AttributeValue
  errors: [Error!]!
}

input AttributeValueUpdateInput {
  fileUrl: String
  name: String
  plainText: String
  value: String
}

type BulkItemError {
  """The error code."""
  code: String

  """
  Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field.
  """
  field: String

  """Index of an input list item that caused the error."""
  index: Int

  """The error message."""
  message: String
}

type Category implements Node {
  id: ID!
  name: String!
  slug: String
  totalEntries: Int
  type: EntryTypeEnum
}

"""Deletes categories."""
type CategoryBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type CategoryCountableConnection {
  edges: [CategoryCountableEdge!]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """A total count of items in the collection."""
  totalCount: Int
}

type CategoryCountableEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Category!
}

type CategoryCreate {
  category: Category
  errors: [Error!]!
}

type CategoryDelete {
  category: Category
  errors: [Error!]!
}

input CategoryFilterInput {
  ids: [ID!]
  search: String
  type: EntryTypeEnum
}

input CategoryInput {
  name: String
  slug: String
  type: EntryTypeEnum
}

enum CategorySortField {
  NAME
}

input CategorySortingInput {
  direction: OrderDirection!

  """Sort categories by the selected field."""
  field: CategorySortField!
}

type CategoryUpdate {
  category: Category
  errors: [Error!]!
}

type Channel implements Node {
  id: ID!
  isActive: Boolean!
  name: String!
  slug: String!
}

type ChannelActivate {
  channel: Channel
  errors: [Error!]!
}

type ChannelCreate {
  channel: Channel
  errors: [Error!]!
}

type ChannelDeactivate {
  channel: Channel
  errors: [Error!]!
}

type ChannelDelete {
  channel: Channel
  errors: [Error!]!
}

input ChannelInput {
  isActive: Boolean
  name: String!
  slug: String!
}

type ChannelUpdate {
  channel: Channel
  errors: [Error!]!
}

type ConfigurationItem {
  helpText: String
  label: String
  name: String!
  type: ConfigurationTypeFieldEnum
  value: String
}

input ConfigurationItemInput {
  name: String!
  value: String
}

"""An enumeration."""
enum ConfigurationTypeFieldEnum {
  BOOLEAN
  MULTILINE
  OUTPUT
  PASSWORD
  SECRET
  SECRETMULTILINE
  STRING
}

type Consult implements Node {
  created: DateTime
  entry: Entry
  id: ID!
  plugin: String
  response: JSONString
}

type ConsultDocument {
  entry: Entry
  errors: [Error!]!
}

"""Create JWT token."""
type CreateToken {
  """CSRF token required to re-generate access token."""
  csrfToken: String
  errors: [Error!]!

  """JWT refresh token, required to re-generate access token."""
  refreshToken: String

  """JWT token, required to authenticate."""
  token: String

  """A user instance."""
  user: User
}

"""
The `Date` scalar type represents a Date
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Date

input DateRangeInput {
  """Start date."""
  gte: Date

  """End date."""
  lte: Date
}

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

input DateTimeRangeInput {
  """Start date."""
  gte: DateTime

  """End date."""
  lte: DateTime
}

"""Deactivate all JWT tokens of the currently authenticated user."""
type DeactivateAllUserTokens {
  errors: [Error!]!
}

"""The `Decimal` scalar type represents a python Decimal."""
scalar Decimal

type Document implements Node {
  created: DateTime
  defaultFile: DocumentFile
  description: String
  entry: Entry

  "\n\nRequires one of the following permissions: MANAGE_EVENTS."
  events: [Event!]
  expired: Boolean
  expires: Boolean

  "\n\nRequires one of the following permissions: MANAGE_DOCUMENTS."
  files: [DocumentFile!]
  id: ID!
  isPublished: Boolean
  loadType: DocumentLoadOptionsEnum
  name: String!
  publicationDate: Date
  updated: DateTime
}

"""Deletes segments."""
type DocumentBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type DocumentCountableConnection {
  edges: [DocumentCountableEdge!]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """A total count of items in the collection."""
  totalCount: Int
}

type DocumentCountableEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Document!
}

type DocumentCreate {
  document: Document
  errors: [Error!]!
}

type DocumentDelete {
  document: Document
  errors: [Error!]!
}

type DocumentFile implements Node {
  beginDate: Date
  created: DateTime
  document: Document
  expirationDate: Date
  file: File

  """The ID of the object."""
  id: ID!
  status: DocumentFileStatusEnum
  updated: DateTime
}

type DocumentFileDelete {
  documentFile: DocumentFile
  errors: [Error!]!
}

"""An enumeration."""
enum DocumentFileStatusEnum {
  APPROVED
  REFUSED
  WAITING
}

input DocumentFilterInput {
  beginDate: DateRangeInput
  expirationDate: DateRangeInput
  expires: Boolean
  isPublished: Boolean
  search: String
  type: EntryTypeEnum
  waiting: Boolean
}

input DocumentInput {
  beginDate: Date
  description: String
  entry: ID
  expirationDate: Date
  expires: Boolean
  file: Upload
  isPublished: Boolean
  loadType: DocumentLoadOptionsEnum
  name: String
  provider: ID
  publicationDate: Date
}

type DocumentLoad implements Node {
  document: Document
  documentFile: DocumentFile
  errorMessage: String
  id: ID!
  status: DocumentLoadStatusEnum
}

"""An enumeration."""
enum DocumentLoadOptionsEnum {
  CND
  CNDT
  CNEP
  EMPTY
  FGTS
  JUCESP
  MEI
  SEFAZ_MG
  SEFAZ_SP
  TCU
}

"""An enumeration."""
enum DocumentLoadStatusEnum {
  ERROR
  PENDING
  SUCCESS
}

enum DocumentSortField {
  CREATED
}

input DocumentSortingInput {
  direction: OrderDirection!

  """Sort documents by the selected field."""
  field: DocumentSortField!
}

type DocumentUpdate {
  document: Document
  errors: [Error!]!
}

type DocumentUpdateByEntry {
  documentFile: DocumentFile
  errors: [Error!]!
}

input DocumentUpdateByEntryInput {
  beginDate: Date
  expirationDate: Date
  file: Upload
}

type Entry implements Node {
  attributes: [SelectedAttribute!]!
  categories: [Category!]
  channel: String

  "\n\nRequires one of the following permissions: MANAGE_ENTRIES."
  channelListings: [EntryChannelListing!]
  consult: [Consult!]
  created: DateTime
  documentNumber: String
  documents(after: String, before: String, first: Int, last: Int): DocumentCountableConnection
  email: String
  id: ID!
  name: String!
  slug: String
  type: EntryTypeEnum
  updated: DateTime
}

"""Deletes entries."""
type EntryBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type EntryChannelListing implements Node {
  channel: Channel!
  id: ID!
  isActive: Boolean!
  isPublished: Boolean!
}

type EntryChannelListingError {
  """List of attributes IDs which causes the error."""
  attributes: [ID!]

  """List of channels IDs which causes the error."""
  channels: [ID!]

  """The error code."""
  code: String

  """
  Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field.
  """
  field: String

  """The error message."""
  message: String

  """List of attribute values IDs which causes the error."""
  values: [ID!]
}

type EntryChannelListingUpdate {
  entry: Entry
  errors: [EntryChannelListingError!]!
}

input EntryChannelListingUpdateInput {
  removeChannels: [ID!]
  updateChannels: [PublishableChannelListingInput!]
}

type EntryCountableConnection {
  edges: [EntryCountableEdge!]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """A total count of items in the collection."""
  totalCount: Int
}

type EntryCountableEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Entry!
}

type EntryCreate {
  entry: Entry
  errors: [EntryError!]!
}

type EntryDelete {
  entry: Entry
  errors: [Error!]!
}

type EntryError {
  """List of attributes IDs which causes the error."""
  attributes: [ID!]

  """The error code."""
  code: String

  """
  Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field.
  """
  field: String

  """The error message."""
  message: String

  """List of attribute values IDs which causes the error."""
  values: [ID!]
}

input EntryFilterInput {
  attributes: [AttributeInput!]
  categories: [ID!]
  channel: String
  isPublished: Boolean
  search: String
  type: EntryTypeEnum
}

input EntryInput {
  active: Boolean
  address: String
  attributes: [AttributeValueInput!]
  categories: [ID!]
  documentNumber: String
  email: String
  isPublished: Boolean
  name: String
  phone: String
  publicationDate: Date
  slug: String
  type: EntryTypeEnum
}

enum EntrySortField {
  CREATED
  NAME
  PUBLISHED
  UPDATED
}

input EntrySortingInput {
  direction: OrderDirection!

  """Sort entries by the selected field."""
  field: EntrySortField!
}

"""An enumeration."""
enum EntryTypeEnum {
  PROVIDER
  VEHICLE
}

type EntryUpdate {
  entry: Entry
  errors: [EntryError!]!
}

"""Represents an error in the input of a mutation."""
type Error {
  """The error code."""
  code: String

  """
  Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field.
  """
  field: String

  """The error message."""
  message: String
}

type Event implements Node {
  date: DateTime
  document: Document
  documentName: String
  id: ID!
  message: String
  parameters: JSONString

  """Order event type."""
  type: EventTypesEnum
  user: User
  userEmail: String
}

type EventCountableConnection {
  edges: [EventCountableEdge!]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """A total count of items in the collection."""
  totalCount: Int
}

type EventCountableEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Event!
}

"""An enumeration."""
enum EventTypesEnum {
  DOCUMENT_APPROVED
  DOCUMENT_CREATED
  DOCUMENT_DECLINED
  DOCUMENT_DELETED
  DOCUMENT_LOADED_FAIL
  DOCUMENT_LOADED_FROM_API
  DOCUMENT_RECEIVED
  DOCUMENT_REQUESTED
  DOCUMENT_UPDATED
  ENTRY_CREATED
  ENTRY_DELETED
  ENTRY_UPDATED
}

type File {
  url: String!
}

"""
The `GenericScalar` scalar type represents a generic
GraphQL scalar value that could be:
String, Boolean, Int, Float, List or Object.
"""
scalar GenericScalar

input IntRangeInput {
  """Value greater than or equal to."""
  gte: Int

  """Value less than or equal to."""
  lte: Int
}

type Investment implements Node {
  id: ID!
  isPublished: Boolean
  items: [Item!]
  month: Int!
  year: Int!
}

"""Deletes segments."""
type InvestmentBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type InvestmentCountableConnection {
  edges: [InvestmentCountableEdge!]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """A total count of items in the collection."""
  totalCount: Int
}

type InvestmentCountableEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Investment!
}

type InvestmentCreate {
  errors: [Error!]!
  investment: Investment
}

type InvestmentDelete {
  errors: [Error!]!
  investment: Investment
}

input InvestmentFilterInput {
  isPublished: Boolean

  """"""
  month: Float

  """"""
  year: Float
}

input InvestmentInput {
  isPublished: Boolean
  items: [ItemCreateInput!]
  month: Int
  year: Int
}

enum InvestmentSortField {
  CREATED
}

input InvestmentSortingInput {
  direction: OrderDirection!

  """Sort investments by the selected field."""
  field: InvestmentSortField!
}

type InvestmentUpdate {
  errors: [Error!]!
  investment: Investment
}

input InvestmentUpdateInput {
  addItems: [ItemCreateInput!]
  isPublished: Boolean
  month: Int
  removeItems: [ID!]
  year: Int
}

type Item implements Node {
  id: ID!
  investment: Investment
  name: String!
  value: Decimal
}

type ItemBulkCreate {
  errors: [BulkItemError!]!
  items: [Item]
}

input ItemBulkInput {
  name: String
  value: Float
}

type ItemCreate {
  errors: [Error!]!
  investment: Item
  item: Item
}

input ItemCreateInput {
  name: String!
  value: Float!
}

type ItemDelete {
  errors: [Error!]!
  item: Item
}

input ItemInput {
  investment: ID
  name: String
  value: Float
}

type ItemUpdate {
  errors: [Error!]!
  item: Item
}

"""
Allows use of a JSON String for input / output from the GraphQL schema.

Use of this type is *not recommended* as you lose the benefits of having a defined, static
schema (one of the key benefits of GraphQL).
"""
scalar JSONString

type LoadNewDocumentFromAPI {
  documentLoad: DocumentLoad
  errors: [Error!]!
}

type Mutation {
  approveDocumentFile(id: ID!): ApproveDocumentFile
  attributeCreate(input: AttributeCreateInput!): AttributeCreate
  attributeDelete(externalReference: String, id: ID): AttributeDelete
  attributeUpdate(id: ID, input: AttributeUpdateInput!): AttributeUpdate
  attributeValueCreate(attribute: ID!, input: AttributeValueCreateInput!): AttributeValueCreate
  attributeValueDelete(id: ID): AttributeValueDelete
  attributeValueUpdate(externalReference: String, id: ID, input: AttributeValueUpdateInput!): AttributeValueUpdate

  """Deletes categories."""
  categoryBulkDelete(
    """List of category IDs to delete."""
    ids: [ID!]!
  ): CategoryBulkDelete
  categoryCreate(input: CategoryInput!): CategoryCreate
  categoryDelete(id: ID): CategoryDelete
  categoryUpdate(id: ID, input: CategoryInput!): CategoryUpdate
  channelActivate(id: ID!): ChannelActivate
  channelCreate(input: ChannelInput!): ChannelCreate
  channelDeactivate(id: ID!): ChannelDeactivate
  channelDelete(
    """ID of a channel to delete."""
    id: ID!
  ): ChannelDelete
  channelUpdate(id: ID!, input: ChannelInput!): ChannelUpdate
  consultDocument(id: ID!): ConsultDocument

  """Deletes segments."""
  documentBulkDelete(ids: [ID!]!): DocumentBulkDelete
  documentCreate(input: DocumentInput!): DocumentCreate
  documentDelete(id: ID): DocumentDelete
  documentFileDelete(id: ID): DocumentFileDelete
  documentUpdate(id: ID, input: DocumentInput!): DocumentUpdate
  documentUpdateByEntry(input: DocumentUpdateByEntryInput, token: String): DocumentUpdateByEntry

  """Deletes entries."""
  entryBulkDelete(
    """List of entries IDs to delete."""
    ids: [ID!]!
  ): EntryBulkDelete
  entryChannelListingUpdate(id: ID!, input: EntryChannelListingUpdateInput!): EntryChannelListingUpdate
  entryCreate(input: EntryInput!): EntryCreate
  entryDelete(id: ID): EntryDelete
  entryUpdate(id: ID, input: EntryInput!): EntryUpdate

  """Deletes segments."""
  investmentBulkDelete(
    """List of segments IDs to delete."""
    ids: [ID!]!
  ): InvestmentBulkDelete
  investmentCreate(input: InvestmentInput!): InvestmentCreate
  investmentDelete(id: ID): InvestmentDelete
  investmentUpdate(id: ID, input: InvestmentUpdateInput!): InvestmentUpdate
  itemBulkCreate(investmentId: ID, items: [ItemBulkInput]!): ItemBulkCreate
  itemCreate(input: ItemInput!, investmentId: ID!): ItemCreate
  itemDelete(id: ID): ItemDelete
  itemUpdate(id: ID, input: ItemInput!): ItemUpdate
  loadNewDocumentFromApi(id: ID!): LoadNewDocumentFromAPI
  passwordReset(email: String!, password: String!, token: String!): SetPassword
  pluginUpdate(channelId: ID, id: ID!, input: PluginUpdateInput!): PluginUpdate
  refuseDocumentFile(id: ID!): RefuseDocumentFile
  requestNewDocument(id: ID!): RequestNewDocument
  requestPasswordReset(email: String!, redirectUrl: String!): RequestPasswordReset
  restoreDocumentFile(id: ID!): RestoreDocumentFile

  """Deletes sessions."""
  sessionBulkDelete(
    """List of sessions IDs to delete."""
    ids: [ID!]!
  ): SessionBulkDelete
  sessionCreate(input: SessionInput!): SessionCreate
  sessionDelete(id: ID): SessionDelete
  sessionUpdate(id: ID, input: SessionInput!): SessionUpdate

  """Create JWT token."""
  tokenCreate(
    """Email of a user."""
    email: String!

    """Password of a user."""
    password: String!
  ): CreateToken

  """
  Refresh JWT token. Mutation tries to take refreshToken from the input.If it fails it will try to take refreshToken from the http-only cookie -refreshToken. csrfToken is required when refreshToken is provided as a cookie.
  """
  tokenRefresh(
    """
    CSRF token required to refresh token. This argument is required when refreshToken is provided as a cookie.
    """
    csrfToken: String

    """Refresh token."""
    refreshToken: String
  ): RefreshToken

  """Verify JWT token."""
  tokenVerify(
    """JWT token to validate."""
    token: String!
  ): VerifyToken

  """Deactivate all JWT tokens of the currently authenticated user."""
  tokensDeactivateAll: DeactivateAllUserTokens
  validateToken(token: String!): ValidateDocumentToken
}

"""An object with an ID"""
interface Node {
  """The ID of the object."""
  id: ID!
}

enum OrderDirection {
  """Specifies an ascending sort order."""
  ASC

  """Specifies a descending sort order."""
  DESC
}

"""
The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
"""
type PageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: String

  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String
}

"""Represents a permission object in a friendly form."""
type Permission {
  """Internal code for permission."""
  code: String!

  """Describe action(s) allowed to do by permission."""
  name: String!
}

"""Plugin."""
type Plugin {
  channelConfigurations: [PluginConfiguration!]!
  description: String!
  globalConfiguration: PluginConfiguration
  id: ID!
  name: String!
}

type PluginConfiguration {
  active: Boolean!
  channel: Channel
  configuration: [ConfigurationItem!]
}

enum PluginConfigurationType {
  GLOBAL
  PER_CHANNEL
}

type PluginCountableConnection {
  edges: [PluginCountableEdge!]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """A total count of items in the collection."""
  totalCount: Int
}

type PluginCountableEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Plugin!
}

input PluginFilterInput {
  search: String
  statusInChannels: PluginStatusInChannelsInput
  type: PluginConfigurationType
}

enum PluginSortField {
  IS_ACTIVE
  NAME
}

input PluginSortingInput {
  direction: OrderDirection!

  """Sort plugins by the selected field."""
  field: PluginSortField!
}

input PluginStatusInChannelsInput {
  active: Boolean!
  channels: [ID!]!
}

type PluginUpdate {
  errors: [Error!]!
  plugin: Plugin
}

input PluginUpdateInput {
  active: Boolean
  configuration: [ConfigurationItemInput!]
}

input PublishableChannelListingInput {
  channelId: ID!
  isActive: Boolean
  isPublished: Boolean
}

type Query {
  attribute(id: ID, slug: String): Attribute
  attributes(after: String, before: String, filter: AttributeFilterInput, first: Int, last: Int, search: String, sortBy: AttributeSortingInput): AttributeCountableConnection
  categories(after: String, before: String, filter: CategoryFilterInput, first: Int, last: Int, sortBy: CategorySortingInput): CategoryCountableConnection
  category(id: ID, slug: String): Category

  """Look up a channel by ID or slug."""
  channel(
    """ID of the channel."""
    id: ID

    """Slug of the channel."""
    slug: String
  ): Channel

  """List of all channels."""
  channels: [Channel!]
  document(id: ID): Document

  "\n\nRequires one of the following permissions: MANAGE_DOCUMENTS."
  documentLoad(id: ID): DocumentLoad
  documents(after: String, before: String, filter: DocumentFilterInput, first: Int, last: Int, sortBy: DocumentSortingInput): DocumentCountableConnection
  entries(after: String, before: String, channel: String, filter: EntryFilterInput, first: Int, last: Int, sortBy: EntrySortingInput): EntryCountableConnection
  entry(channel: String, id: ID, slug: String): Entry

  "\n\nRequires one of the following permissions: MANAGE_EVENTS."
  events(after: String, before: String, first: Int, last: Int): EventCountableConnection
  investment(id: ID, month: Int, year: Int): Investment
  investments(after: String, before: String, filter: InvestmentFilterInput, first: Int, last: Int, sortBy: InvestmentSortingInput): InvestmentCountableConnection
  me: User
  plugin(id: ID!): Plugin
  plugins(after: String, before: String, filter: PluginFilterInput, first: Int, last: Int, sortBy: PluginSortingInput): PluginCountableConnection
  session(id: ID, slug: String): Session
  sessions(after: String, before: String, filter: SessionFilterInput, first: Int, last: Int, sortBy: SessionSortingInput): SessionCountableConnection
}

"""
Refresh JWT token. Mutation tries to take refreshToken from the input.If it fails it will try to take refreshToken from the http-only cookie -refreshToken. csrfToken is required when refreshToken is provided as a cookie.
"""
type RefreshToken {
  errors: [Error!]!

  """JWT token, required to authenticate."""
  token: String

  """A user instance."""
  user: User
}

type RefuseDocumentFile {
  documentFile: DocumentFile
  errors: [Error!]!
}

type RequestNewDocument {
  errors: [Error!]!
}

type RequestPasswordReset {
  errors: [Error!]!
}

type RestoreDocumentFile {
  documentFile: DocumentFile
  errors: [Error!]!
}

"""Represents a custom attribute."""
type SelectedAttribute {
  attribute: Attribute!
  values: [AttributeValue!]!
}

type Session implements Node {
  content: JSONString
  date: DateTime
  id: ID!
  isPublished: Boolean
  name: String!
  slug: String
}

"""Deletes sessions."""
type SessionBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type SessionCountableConnection {
  edges: [SessionCountableEdge!]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """A total count of items in the collection."""
  totalCount: Int
}

type SessionCountableEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Session!
}

type SessionCreate {
  errors: [Error!]!
  session: Session
}

type SessionDelete {
  errors: [Error!]!
  session: Session
}

input SessionFilterInput {
  isPublished: Boolean
  search: String
}

input SessionInput {
  content: JSONString
  date: DateTime
  isPublished: Boolean
  name: String
  slug: String
}

enum SessionSortField {
  NAME
}

input SessionSortingInput {
  direction: OrderDirection!

  """Sort sessions by the selected field."""
  field: SessionSortField!
}

type SessionUpdate {
  entry: Session
  errors: [Error!]!
  session: Session
}

type SetPassword {
  errors: [Error!]!
}

"""
Create scalar that ignores normal serialization/deserialization, since
that will be handled by the multipart request spec
"""
scalar Upload

type User implements Node {
  email: String!
  firstName: String
  id: ID!
  isStaff: Boolean
  lastName: String
  permissions: [Permission]
}

type ValidateDocumentToken {
  document: Document
  errors: [Error!]!
}

"""Verify JWT token."""
type VerifyToken {
  errors: [Error!]!

  """Determine if token is valid or not."""
  isValid: Boolean!

  """JWT payload."""
  payload: GenericScalar

  """User assigned to token."""
  user: User
}